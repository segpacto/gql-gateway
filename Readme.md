## Apollo GraphQL Gateway 

### Description 
This repository is a GraphQL Gateway that allows the interaction with Swagger based REST APIs.
Through this gateway, it is possible to easily establish aggregations between the REST services using GraphQL generated queries and types, and serve all as part of one response.  

### Knowledge Base
- [Swagger](https://swagger.io/docs/)
- [GraphQl Schema Stitching](https://www.apollographql.com/docs/apollo-server/features/schema-stitching/)
- [GraphQl Schema Delegation](https://www.apollographql.com/docs/apollo-server/features/schema-delegation/)


### How this GraphQl-Gateway works
1. Read all swagger endpoints passed that are services REST available.
2. Retrieve from each one of the services published their Swagger Json, build GraphQl Types, Queries and Mutations, as well as auto-generate the resolvers.
3. Merge our local GraphQl definitions with the agreggations and extensions along with the previous generated ones.
4. Publish the GraphQl server with all agreggations. 


## Getting started

### Installation
`npm install --save gql-gateway`

### Publish available Rest Endpoints as GraphQl gateway (How does it works ?)
#### Simpliest scenario :
```js
const gateway = require('gql-gateway')

const endpointsList = [
  { name: 'petstore_service', url: 'https://petstore.swagger.io/v2/swagger.json' },
  { name: 'fruits_service', url: 'https://api.predic8.de/shop/swagger' }
]

gateway({ endpointsList })
  .then(server => server.listen(5000))
  .then(console.log('Service is now running at port: 5000'))
  .catch(err => console.log(err))
```

On the previous implementation we declare a list of swagger json endpoints. This retrieve those json schemas and publish it as graphql (`http://localhost:5000`).
At the same time graphql queries and mutations are automatically generated, allowing to retrieve from the REST APIs declared above using graphql standards.

#### Advanced scenario (Adding aggregations):
```js
const gateway = require('gql-gateway')

const localSchema = `
  extend type Order {
    pet: Pet 
  } 
`

const resolvers = {
  /* 
  Query : {
     ....
  } 
  */   
  Order: {
    pet: {
      fragment: '... on Order {petId}',
      async resolve (order, args, context, info) {
        const schema = await context.resolveSchema('pet_service')

        return info.mergeInfo.delegateToSchema({
          schema,
          operation: 'query',
          fieldName: 'getPetById',
          args: { petId: order.petId },
          context,
          info
        })
      }
    }
  }
}

const config = {
  port: 5000,
  playgroundBasePath: 'gql-gateway'
}

const endpointsList = [
  { name: 'pet_service', url: 'https://petstore.swagger.io/v2/swagger.json' }
]

const ApolloServerConfig = { playground: { endpoint: config.playgroundBasePath } }

gateway({ resolvers, localSchema, endpointsList, ApolloServerConfig })
  .then(server => server.listen(config.port))
  .then(console.log(`Service is now running at port: ${config.port}`))
  .catch(err => console.log(err))
```

`Explanation from Top to bottom` :
    On `localSchema` we declare the aggregations that we would like to have by extending the original schemas (To get the original schemas, queries and mutations is recommended to publish the service and then take a look at them before start adding aggregations). 
   on `resolvers` we declare the way how to resolve the model `Order`, for this it is used graphql `delegation`, where we specify on which of the autogenerated queries or mutations we relay to obtain the `pet` property in `Order`, on this case `getPetById`.
   Note that on the fragment we declare `petId` as ncessary to obtain `pet` property, so `petId` is going to be injected from the `Order` to the resolver even if it haven't been requested originally.


#### gql-gateway server Parameters

| Name                 | Default                     |  Description    |
| -------------------- | --------------------------- | --------------- |
| `localSchema`        | `empty`                     | Schema that contains the aggregations that we want to establish between the REST API services |  
| `resolvers`          | `empty`                     | Resolvers that implement delegation. See samples above |
| `endpointsList`      | `required`                  | Contains a list of `json` swagger endpoints where to retrieve definitions to build the graphql schemas. `Minimum` one element|
| `apolloServerConfig` | `empty`                        | Apollo Server configuration (https://www.apollographql.com/docs/apollo-server/api/apollo-server/#apolloserver)|
| `contextConfig`      | `empty`                     | Object that contains middlewares and also used to inject data into the Context (https://www.apollographql.com/docs/apollo-server/api/apollo-server/#apolloserver) |
| `logger`             | `console`                   | Default logger is the console |


##### Format of `localSchema` parameter
| Name     | Default     | Description |
| -------- | ----------- | ------------- |
| `name`   | `required`  | Is used to identify the service |
| `url`    | `required`  | Url of the service swagger in `json` format |
| `headers`| `empty`     | Headers passed to request the json swagger service, in case any kind of particular auth is needed |

##### Format of `apolloServerConfig`
 Ex : ```js const ApolloServerConfig = { playground: { endpoint: config.playgroundBasePath } }```


### Techical Explanation
Below, we describe how to interact between services swagger based using agreggations(relations). In this case we use the `User` and `Product` services.

1. `User` service
```
...
paths:
    "/users":
        get:
            description: "Return an Array of existing users"
            responses:
                '200':
                    description: "successful operation"
                    schema:
                        type: array
                        items:  
                            "$ref": "#/definitions/User"
...
definitions :
    User:
        type: object
        properties:
            userId:
                type: string
            firstname:
                type: string
            lastname:
                type: string
...
```

2. `Product` service
```
...
paths:
  paths:
    '/products/{userId}':
      get:
        tags:
          - Product
        parameters:
          - name: userId
            in: path
            description: ID of the user to fetch last products
            required: true
            type: string
        summary: Return a summary of the last products
        description: Return a sumary of the user products
        responses:
          '200':
            description: successful operation
            schema:
                type: array
                items:  
                    "$ref": "#/definitions/Product"
...
definitions :
    Product:
        type: object
        properties:
            productId:
                type: string
            userId:
                type: string
            name:
                type: string
            type:
                type: string
...
```

- Once the graphql gateway read from those services json swagger endpoints, our server generates :
```graph
type Queries {
    get_products_userId(userId: String!): Products!
    get_users(): [User]!
}
```

> Now, we need to extend the GraphQL definitions to introduce our user aggregations:

- Extend `GraphQl` Types definitions:
```graph
    extend type User {
        products: Product
    }

    # You can always declare the relation in one direction
    extend type Product {
        user: User
    }
```
> This will automatically indicate to the GraphQl server that the Type `User` will have another field named products which means, the `Product` relations.

- Finally, extend `GraphQl` resolvers:
```js
User: {
    products: {
      fragment: '... on User {userId}',
      async resolve (user, args, context, info) {
        return info.mergeInfo.delegateToSchema({
          schema: userSchema,
          operation: 'query',
          fieldName: 'get_products_userId',
          args: {
            referenceUuid: user.userId
          },
          context,
          info
        })
      }
    }
  },
```

- Get user + products (Ex aggregation)

```graph
mutation {
  post_user_search(body:{}) {
    data {
      firstName,
      lastName,
      products {
        data {
          product
        }
      }
    }
  }
}
````